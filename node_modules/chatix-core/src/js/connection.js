// import {HubConnection} from '@aspnet/signalr-client';
import { HubConnectionBuilder, LogLevel } from '@aspnet/signalr';
import Manager from "./manager";
import Visitor from "./visitor";
import Message from "./message";
import Chatroom from "./chatroom";
import ChatroomMember from "./chatroomMember";
import lzString from "lz-string";
import axios from "axios";

// const API_URL = process.env.API_URL + ':' + process.env.API_PORT + '/' + process.env.API_PATH;
const API_URL = 'https://app1.chatix.io:5022/v1';

/**
 * @class Connection implements Chatix protocol implementation.
 * This class is private and is used inside ChatixCore.
 * @property {Connection~onConnected} onConnected
 * @property {Connection~onDisconnected} onDisconnected
 * @property {Connection~onApplyError} onApplyErrorMessage
 * @property {Connection~onInvalidVisitorIdConnected} onInvalidVisitorIdConnected
 * @property {Connection~onApplyDialogMessage} onApplyDialogMessage
 * @property {Connection~onConnectManagerToConversation} onConnectManagerToConversation
 * @property {Connection~onDisconnectManagerFromConversation} onDisconnectManagerFromConversation
 * @property {Connection~onScreencastRequested} onScreencastRequested
 * @property {Connection~onConnectManagerToScreencast} onConnectManagerToScreencast
 * @property {Connection~onDisconnectManagerFromScreencast} onDisonnectManagerFromScreencast
 * @property {Connection~onScreenDataRequested} onScreenDataRequested
 * @property {Connection~onManagerSentScreenEvent} onManagerSentScreenEvent
 * @property {Connection~onConnectManagerToChatroom} onConnectManagerToChatroom
 * @property {Connection~onDisconnectManagerFromChatroom} onDisconnectManagerFromChatroom
 * @property {Connection~onConnectVisitorToChatroom} onConnectVisitorToChatroom
 * @property {Connection~onDisconnectVisitorFromChatroom} onDisconnectVisitorFromChatroom
 * @property {Connection~onChatroomCreated} onChatroomCreated
 * @property {Connection~onChatroomUpdated} onChatroomUpdated
 * @property {Connection~onChatroomDeleted} onChatroomDeleted
 * @property {Connection~onChatroomRestored} onChatroomRestored
 */
class Connection {

	/**
	 * Connection constructor
    */
   constructor() {
      
      this.onConnected = function(){};
      this.onDisconnected = function(){};
      this.onApplyErrorMessage = function(){};
      /**
       * @todo ждем исправления на бэкенде
       */
      //this.onConversationMessageError = function(){};
      //this.onChatroomMessageError = function(){};
      this.onInvalidVisitorIdConnected = function(){};

      this.onApplyConversationMessage = function(){};
      this.onUpdateConversationMessage = function(){};
      this.onDeleteConversationMessage = function(){};
      this.onConnectManagerToConversation = function(){};
      this.onDisconnectManagerFromConversation = function(){};

      this.onScreencastRequested = function(){};
      this.onConnectManagerToScreencast = function(){};
      this.onDisconnectManagerFromScreenCast = function(){};
      this.onScreenDataRequested = function(){};
      this.onManagerSentScreenEvent = function(){};

      this.onCreateChatroom = function(){};
      this.onUpdateChatroom = function(){};
      this.onDeleteChatroom = function(){};
      this.onRestoreChatroom = function(){};
      this.onConnectManagerToChatroom = function(){};
      this.onDisonnectManagerFromChatroom = function(){};
      this.onConnectVisitorToChatroom = function(){};
      this.onDisconnectVisitorFromChatroom = function(){};
      this.onApplyChatroomMessage = function(){};
      this.onUpdateChatroomMessage = function(){};
      this.onDeleteChatroomMessage = function(){};
   }

   /**
    * Starts connection
    * 
    * @param {string} websiteId Website ID from Chatix Dashboard 
    * @param {string} visitorId Visitor ID that will be used to connect. 
    * If it is invalid, it will be replaced with new one.
    * @returns {Promise<void>}
    */
   async start(websiteId, visitorId) {
      let hubUrl = API_URL + '/chat' + '?visitorId=' + visitorId  + '&websiteId=' + websiteId;

      this.hubConnection = new HubConnectionBuilder()
         .withUrl(hubUrl)
         .configureLogging(LogLevel.Error)
         .build();

      this.hubConnection.serverTimeoutInMilliseconds = 1000 * 1000 * 1000;

      this.hubConnection.on('ApplyErrorMessage', (message, method) => {
         this.onApplyErrorMessage(message, method);
      });

      this.hubConnection.on('OnInvalidVisitorIdConnected',  (message) => {
         this.onInvalidVisitorIdConnected(message);
      });

      this.hubConnection.on("ApplyMessage",  (data) => {
         this.onApplyConversationMessage(Message.buildFromInfo(data));
      });

      this.hubConnection.on("OnConnectManagerToConversation",  (manager) => {
         let m = Manager.buildFromInfo(manager);
         this.onConnectManagerToConversation(m);
      });

      this.hubConnection.on("OnDisconnectManagerFromConversation",  (manager) => {
         let m = Manager.buildFromInfo(manager);
         this.onDisconnectManagerFromConversation(m);
      });

      this.hubConnection.on("OnRequestScreenCast",  () => {
         this.onScreencastRequested();
      });


      /**
       * @todo Ждем обновления бэкенда
       */
      this.hubConnection.on("OnConnectManagerToScreencast", (manager) => {
         let m = Manager.buildFromInfo(manager);
         this.onConnectManagerToScreencast(m);
      });

      /**
       * @todo проверить аргументы callback
       */
      this.hubConnection.on("OnDisconnectManagerFromScreenCast",  (manager) => {
         let m = Manager.buildFromInfo(manager);
         this.onManagerDisconnectFromScreenCast(m);
      });

      this.hubConnection.on("OnGetScreenData",  () => {
         this.onScreenDataRequested();
      });

      this.hubConnection.on("OnPostScreenEventByManager",  (data) => {
         this.onManagerSentScreenEvent(data);
      });

      this.hubConnection.on('ApplyChatroomMessage',  (message, chatroomId) => {
         let m = Message.buildFromInfo(message);

         this.onApplyChatroomMessage(chatroomId, m);
      });

      this.hubConnection.on("OnConnectManagerToChatroom",  (manager, chatroomId) => {
         let m = Manager.buildFromInfo(manager);
         this.onConnectManagerToChatroom(chatroomId, m);
      });

      this.hubConnection.on("OnConnectVisitorToChatroom",  (member, chatroomId) => {
         let v = ChatroomMember.buildFromInfo(member);
         this.onMemberConnectedToChatroom(chatroomId, v);
      });

      this.hubConnection.on("OnDisconnectManagerFromChatroom",  (manager, chatroomId) => {
         let m = Manager.buildFromInfo(manager);
         this.onManagerDisconnectedFromChatroom(chatroomId, m);
      });

      this.hubConnection.on("OnDisconnectVisitorFromChatroom",  (member, chatroomId) => {
         let v = ChatroomMember.buildFromInfo(member);
         this.onMemberDisconnectedFromChatroom(chatroomId, v);
      });

      this.hubConnection.on("OnCreateChatroom",  (chatroom) => {
         let c = Chatroom.buildFromInfo(chatroom);
         this.onCreateChatroom(c);
      });

      this.hubConnection.on("OnUpdateChatroom",  (chatroom) => {
         let c = Chatroom.buildFromInfo(chatroom);
         this.onUpdateChatroom(c);
      });

      this.hubConnection.on("OnDeleteChatroom",  (chatroomId) => {
         this.onDeleteChatroom(chatroomId);
      });

      this.hubConnection.on("OnRestoreChatroom",  (chatroom) => {
         let c = Chatroom.buildFromInfo(chatroom);
         this.onRestoreChatroom(c);
      });

      this.hubConnection.on("OnUpdateConversationMessage",  (message) => {
         let m = Message.buildFromInfo(message);
         this.onUpdateDialogMessage(m);
      });

      this.hubConnection.on("OnDeleteConversationMessage",  (messageId) => {
         this.onDeleteConversationMessage(messageId);
      });

      this.hubConnection.on("OnUpdateChatroomMessage",  (message) => {
         let m = Message.buildFromInfo(message);
         this.onChatroomMessageUpdated(m);
      });

      this.hubConnection.on("OnDeleteChatroomMessage",  (messageId) => {
         this.onChatroomMessageDeleted(messageId);
      });

      this.hubConnection.on("OnConnectManagerToScreenCast",  (manager) => {
         let m = Manager.buildFromInfo(manager);
         this.onManagerConnectedToScreenCast(m);
      });

      this.hubConnection.on("ApplyVisitorInfo",  (visitor) => {
         let v = Visitor.buildFromInfo(visitor);
         this.onApplyVisitorInfo(v);
      });


      const start = async () => {
         try {
            this.hubConnection.start();
         } catch (err) {
            console.log(err);
            setTimeout(() => start(), 5000);
         }
      }

      this.hubConnection.onclose(async () => {
         await start();
      });

      return await this.hubConnection.start();
   }


   /**
    * Gets new visitor ID if passed was invalid.
    * @param {string} websiteId Website ID from Chatix dashboard
    * @returns {Promise<string>}
    */
   async getNewVisitorId(websiteId) {
      try {
         let response = await axios.get(API_URL + '/visitor/get-id?websiteId=' + websiteId);
         if (response.status !== 200) {
            throw new Error("Error occured while trying to get new visitor ID. Status response status code: " + response.status);
         }
         return response.data;
      } catch (e) {
         console.error(e);
         throw e;
      }
   }

   /**
    * Interrupts connection
    * 
    */
   async stop() {
      if (!this.hubConnection) {
         throw new Error("Connection has to be established");
      }
      return await this.hubConnection.stop();
   }

   /**
    * Sends current user input to managers
    *
    * @param {string} text what user is typing
    * @returns {void}
    */
   async sendVisitorTypedText(text) {
      return await this.hubConnection.invoke('VisitorType', text);
   }

   /**
    * Sends visitor details update to manager
    *
    * @param {Visitor} visitor
    * @returns {Visitor} updated visitor entity
    */
   async sendVisitorInfo(visitor) {
      let apiVisitor = await this.hubConnection.invoke('SaveVisitorInfo', visitor);
      return Visitor.buildFromInfo(apiVisitor);
   }

   /**
    * Send user choise for screencast request.
    * 
    * @param {bool} flag User choise to allow screencast. TRUE - allow, FALSE - disallow.
    */
   async allowScreenCast(flag) {
      return await this.hubConnection.invoke('AllowScreenCast', flag);
   }

   /**
    * Sends screencast interruption event to managers
    * 
    * @returns {void}
    */
   async interruptScreenCast() {
      return await this.hubConnection.invoke('InterruptScreenCast');
   }

   /**
    * Gets all website managers
    * 
    * @returns {Manager[]}
    */
   async getWebChatManagers() {
      let apiManagers = await this.hubConnection.invoke('GetWebChatManagers');
      let managers = [];
      for (let m of apiManagers) {
         managers.push(Manager.buildFromInfo(m));
      }
      return managers;
   }

   /**
    * Gets all *connected to visitor* website managers
    * 
    * @returns {Manager[]}
    */
   async getConnectedToConversationManagers() {
      let apiManagers = await this.hubConnection.invoke('GetManagers');
      let managers = [];
      for (let m of apiManagers) {
         managers.push(Manager.buildFromInfo(m));
      }
      return managers;
   }

   /**
    * Gets webchat config
    * 
    * @returns {object}
    */
   async getWebChatInfo() {
      return await this.hubConnection.invoke('GetWebChatInfo');
   }

   /**
    * Gets current visitor information from server
    *
    * @returns {Visitor}
    */
   async getVisitorInfo() {
      let apiVisitor = await this.hubConnection.invoke('GetVisitorInfo', null);
      return Visitor.buildFromInfo(apiVisitor);
   }

   /**
    * Gets manager infromation by his id
    *
    * @param {string} managerId Manager's id
    * @returns {Promise<Manager>}
    */
   async getManagerInfo(managerId) {
      let apiManager = await this.hubConnection.invoke('GetManagerInfo', managerId);
      return Manager.buildFromInfo(apiManager);
   }

   /**
    * Gets messages from dialog between visitor and managers.
    *
    * @param {string|null} lastKnownMessageId last displayed message ID. If NULL, it will return 
    * last messages in dialog
    * @param {number} count Number of messages to return. Can be between 1 and 100.
    * @returns {Promise<Message[]>}
    * @throws {Error}
    */
   async getConversationHistory(lastKnownMessageId = null, count = 30) {
      if (count < 1 || count > 100) {
         throw new Error("Count param is invalid. Valid values are between 1 and 100");
      }
      let apiMessages = await this.hubConnection.invoke('GetHistory', null, lastKnownMessageId, count);
      let messages = [];
      for (let m of apiMessages.items) {
         messages.push(Message.buildFromInfo(m));
      }
      return messages;
   }

   /**
    * Gets messages from specific Chatroom.
    *  
    * @param {string} chatroomId Chatroom ID 
    * @param {string|null} lastKnownMessageId last displayed message ID. If NULL, it will return 
    * last messages in dialog
    * @param {number} count Number of messages to return. Can be between 1 and 100.
    * @returns {Message[]}
    */
   async getChatroomHistory(chatroomId, lastKnownMessageId = null, count = 30) {
      if (count < 1 || count > 100) {
         throw new Error("Count param is invalid. Valid values are between 1 and 100");
      }
      let apiMessages = await this.hubConnection.invoke('GetChatroomHistory', chatroomId, lastKnownMessageId, count);
      let messages = [];
      for (let m of apiMessages.items) {
         messages.push(Message.buildFromInfo(m));
      }
      return messages;
   }

   /**
    * Returns current connection state as **INT**
    * @todo перепроверить. отдает 2, хотя уже подключен.
    * @return {number}
    */
   getConnectionState() {
      switch (this.hubConnection.connectionState) {
         case 2:
            return Connection.STATE_CONNECTING;
         case 1:
            return Connection.STATE_CONNECTED;
         default:
            return Connection.STATE_DISCONNECTED;
      }
   }

   /**
    * Returns current connection state as **STRING**
    * 
    * @return {string}
    */
   getConnectionStateDescription() {
      switch (this.hubConnection.connection.connectionState) {
         case 1:
            return "Connecting";
         case 2:
            return "Connected";
         default:
            return "Disconnected";
      }
   }

   /**
    * Sends message to conversation
    *
    * @param {Message} message
    * @return {Message} saved message instance
    */
   async sendMessage(message) {
      let apiMessage = await this.hubConnection.invoke('SaveMessage', message, null);
      return Message.buildFromInfo(apiMessage);
   }

   /**
    * Sends user navigation thought pages
    *
    * @param {string} url current page URL
    * @param {string} title current page title
    * @return {void}
    */
   async sendPage(url, title) {
      await this.hubConnection.invoke('SavePageInfo', url, title);
   }

   /**
    * Sends data to screencast
    * 
    * @returns {void}
    */
   async sendBroadcastData(innerHTML, broadcastData) {
      return await this.hubConnection.invoke('PostScreenData', lzString.compressToUTF16(innerHTML), broadcastData);
   }


   /**
    * Sends screencast event to consultants
    * 
    * @param {object} broadcastEvent 
    */
   async sendBroadcastEvent(broadcastEvent) {
      let broadcastEventData = broadcastEvent;
      if (broadcastEventData.mutations) {
         if (broadcastEventData.mutations.length > 0) {
            broadcastEventData.mutations.forEach(function (item) {
               if (item.target) {
                  item.target = lzString.compressToUTF16(item.target);
               }
            });
         }
      }

      return await this.hubConnection.invoke('PostScreenEvent', broadcastEventData, null, null);
   }

   /**
    * Sends text message to specific Chatroom
    * 
    * @param {Message} text Text to be sent to Chatroom
    * @param {string} chatroomId Chatroom ID where message has to be sent
    * @returns {Message} saved message
    */
   async sendChatroomMessage(message, chatroomId) {
      return Message.buildFromInfo(await this.hubConnection.invoke('SaveChatroomMessage', message, chatroomId));
   }

   /**
    * Gets Chatroom from backend
    * 
    * @param {string} chatroomId Chatroom ID
    */
   async getChatroom(chatroomId) {
      return Chatroom.buildFromInfo(await this.hubConnection.invoke('GetChatroom', chatroomId));
   }

   /**
    * Connects visitor to Chatroom
    * 
    * @param {string} chatroomId Chatroom ID
    */
   async connectToChatroom(chatroomId) {
      let result = await this.hubConnection.invoke('ConnectToChatroom', chatroomId);
      if (result.is_success) {
         return true;
      } else {
         throw new Error(result.description);
      }
   }

   /**
    * Disconnects visitor from Chatroom
    * 
    * @param {string} chatroomId Chatroom ID
    */
   async disconnectFromChatroom(chatroomId) {
      let result = await this.hubConnection.invoke('DisconnectFromChatroom', chatroomId);
      if (result.is_success) {
         return true;
      } else {
         throw new Error(result.description);
      }
   }

   /**
    * Gets all avaliable chatrooms ordered by title.
    * 
    * @param {number} page Number of page to deliver
    * @param {number} itemsPerPage Number of items per page
    */
   async getAllChatrooms(page = 1, itemsPerPage = 100) {
      return await this.hubConnection.invoke('GetAllChatrooms', itemsPerPage, page, false);
   }

   /**
    * Gets all chatrooms with current visitor ordered by title.
    * 
    * @param {number} page Number of page to deliver
    * @param {number} itemsPerPage Number of items per page
    */
   async getMyChatrooms(page = 1, itemsPerPage = 100) {
      let response = await this.hubConnection.invoke('GetMyChatrooms', itemsPerPage, page, false);
      let chatrooms = [];
      for (const c of response.items) {
         chatrooms.push(Chatroom.buildFromInfo(c));
      }
      return chatrooms;
   }

   /**
    * Gets information about another visitor. It returns object similar to Visitor, but without private
    * fields like email, fields, location, etc. If you need to receive this information, use REST API.
    * 
    * @param {string} visitorId Another visitor ID
    */
   async getMember(memberId) {
      return ChatroomMember.buildFromInfo(await this.hubConnection.invoke('GetVisitorByVisitor', memberId));
   }
   
   /**
    * Gets visitors from specific Chatroom. If current visitor is connected to chatroom, response may
    * contain himself.
    * 
    * @param {string} chatroomId Which chatroom visitors return
    * @param {number} itemsPerPage Number of visitors to return per page
    * @param {number} page Data page number
    */
   async getChatroomMembers(chatroomId, itemsPerPage = 10, page = 1) {
      let apiMembers = await this.hubConnection.invoke('GetChatroomVisitors', chatroomId, page, itemsPerPage);
      let result = [];
      for (const member of apiMembers.items) {
         result.push(ChatroomMember.buildFromInfo(member));
      }
      return result;
   }


}

Connection.STATE_CONNECTING = 1;
Connection.STATE_CONNECTED = 2;
Connection.STATE_DISCONNECTED = 3;

export default Connection;

/**
 * @callback Connection~onConnected
 */

/**
 * @callback Connection~onDisconnected
 */

/**
 * @callback Connection~onApplyError
 * @param {string} message Error description
 * @param {string} method Method name where error occured
 */


/**
 * @callback Connection~onInvalidVisitorIdConnected
 * @param {string} message
 */

/**
 * @callback Connection~onApplyDialogMessage
 * @param {Message} message
 */

/**
 * @callback Connection~onConnectManagerToConversation
 * @param {Manager} manager
 */

/**
 * @callback Connection~onDisonnectManagerFromConversation
 * @param {Manager} manager
 */

/**
 * @callback Connection~onScreencastRequested
 */
/**
 * @callback Connection~onConnectManagerToScreencast
 * @param {Manager} manager
 */
/**
 * @callback Connection~onDisconnectManagerFromScreencast
 * @param {Manager} manager
 */
/**
 * @callback Connection~onScreenDataRequested
 */
/**
 * @callback Connection~onManagerSentScreenEvent
 * @param {object} event
 */
/**
 * @todo ждем обновление бэкенда на предмет добавление второго аргумента
 * @callback Connection~onConnectManagerToChatroom
 * @param {Manager} manager
 * @param {string} chatroomId
 */
/**
 * @todo ждем обновление бэкенда на предмет добавление второго аргумента
 * @callback Connection~onDisconnectManagerFromChatroom
 * @param {Manager} manager
 * @param {string} chatroomId
 */
/**
 * @todo ждем обновление бэкенда на предмет добавление второго аргумента
 * @callback Connection~onConnectVisitorToChatroom
 * @param {ChatroomMember} visitor
 * @param {string} chatroomId
 */
/**
 * @todo ждем обновление бэкенда на предмет добавление второго аргумента
 * @callback Connection~onDisconnectVisitorFromChatroom
 * @param {ChatroomMember} visitor
 * @param {string} chatroomId
 */
/**
 * @callback Connection~onChatroomCreated
 * @param {Chatroom} chatroom
 */
/**
 * @callback Connection~onChatroomUpdated
 * @param {Chatroom} chatroom
 */
/**
 * @callback Connection~onChatroomDeleted
 * @param {string} chatroomId
 */
/**
 * @callback Connection~onChatroomRestored
 * @param {Chatroom} chatroom
 */