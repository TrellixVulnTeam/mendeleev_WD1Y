class ScreenBroadcast {
	constructor(chat){
		this.areaRemoveTimeout = null;

		// console.log('BROADCAST SCREEN');
		if (chat.connection) {
			if (chat.connection.hubConnection.connection.connectionState) {
				// Добавляем обработчик скролла к странице
				document.addEventListener('scroll', function(){
					if (localStorage.getItem('screenBroadcast')) {
						let scrollTop;
						if (document.documentElement.scrollTop > document.body.scrollTop) {
							scrollTop = document.documentElement.scrollTop;
						}
						else {
							scrollTop = document.body.scrollTop;
						}

						let elemScroll = {
							name: 'scrollBody',
							scrollTop: scrollTop,
							scrollLeft: document.documentElement.scrollLeft
						};

						chat.sendBroadcastEvent(elemScroll);
					}
				});

				// ТРАНСЛЯЦИЯ ЭКРАНА ВИЗИТОРА
				// объект со всеми параметрами трансляции
				let broadcastData = {};

				// создаем новый div с копией innerHTML для того, что бы в нем скрыть не транслируемые эллементы не затрагивая основную страницу
				let correctHTML = document.getElementsByTagName('html')[0].cloneNode(true);
				let scrolledElems = [];

				// Получаем позицию курсора при перемещении
				window.addEventListener('mousemove', function (event) {
					if (localStorage.getItem('screenBroadcast')) {
						let broadcastData = {
							name: 'mousemove',
							posX: event.clientX,
							posY: event.clientY
						};

						chat.sendBroadcastEvent(broadcastData);
					}
				});

				// Добавляем обработчик скролла ко всем div на странице
				document.querySelectorAll('div').forEach(function (item) {
					item.addEventListener('scroll', function (event) {
						if (localStorage.getItem('screenBroadcast')) {
							let elemScroll = {
								name: 'scroll',
								target: getDomPath(event.target),
								scrollTop: event.target.scrollTop,
								scrollLeft: event.target.scrollLeft
							};

							chat.sendBroadcastEvent(elemScroll);
						}
					});
				});

				// Отслеживаем событие клика
				document.addEventListener('click', function () {
					if (localStorage.getItem('screenBroadcast')) {
						let broadcastData = {
							name: 'click'
						};

						chat.sendBroadcastEvent(broadcastData);
					}
				}.bind(this));

				// Обрабатываем событие изменения размера экрана
				window.addEventListener('resize', function () {
					if (localStorage.getItem('screenBroadcast')) {
						let broadcastData = {
							name: 'resizeWindow',
							width: document.body.clientWidth,
							height: window.innerHeight
						};

						chat.sendBroadcastEvent(broadcastData);
					}
				}.bind(this));

				// Обрабатываем событие изменения текста в инпутах
				document.body.addEventListener('input', function (e) {
					if (localStorage.getItem('screenBroadcast')) {
						if (e.target.getAttribute('type') !== 'password') {
							let broadcastData = {
								name: 'inputChange',
								target: getDomPath(e.target),
								value: e.target.value
							};

							chat.sendBroadcastEvent(broadcastData);
						}
					}
				});

				// Следим за изменениями в DOM дереве
				// выбираем целевой элемент
				let observTarget = document.body;

				let mutationsArray = {
					name: 'mutation',
					mutations: []
				};


				// отправляем массив с мутациями через интервал времени
				setInterval(function () {
					if (mutationsArray.mutations.length > 0) {
						chat.sendBroadcastEvent(mutationsArray);
						mutationsArray.mutations = [];
					}
				}, 250);

				// создаём экземпляр MutationObserver
				let observer = new MutationObserver(function (mutations) {
					if (localStorage.getItem('screenBroadcast')) {
						mutations.forEach(function (mutation) {
							if (mutation.target.tagName) {
								if (mutation.target.tagName.toLowerCase() != 'ymaps') {
									let elemMutation;
									// if (mutation.type === 'childList' && mutation.target.tagName.toLowerCase() === 'body') {
									// if (false) {
									// 	let mutationAddRemove = {};

									// 	if (mutation.addedNodes.length > 0) {
									// 		// Удаляем из добавленного узла data атрибуты
									// 		let copyMutationTarget = mutation.addedNodes[0].cloneNode(true)
									// 		let muationAttrs = mutation.addedNodes[0].attributes;
									// 		for (var i = 0; i < muationAttrs.length; i++) {
									// 			if (muationAttrs[i].name.indexOf('data-') === 0) {
									// 				copyMutationTarget.removeAttribute(muationAttrs[i].name);
									// 			}
									// 		}

									// 		// удаляем из добавленного узла скрипты
									// 		copyMutationTarget.querySelectorAll('*').forEach(function (item, i) {
									// 			if (item.tagName.toLowerCase() === 'script') {
									// 				item.remove();
									// 			}
									// 		});

									// 		mutationAddRemove.name = 'addElemMutation';
									// 		mutationAddRemove.target = copyMutationTarget.outerHTML;

									// 		if (mutation.nextSibling) {
									// 			if (mutation.nextSibling.nodeName === '#text') {
									// 				if (mutation.nextSibling.nextElementSibling) {
									// 					mutationAddRemove.nextElemXPath = getDomPath(mutation.nextSibling.nextElementSibling);
									// 				}
									// 			}
									// 			else {
									// 				mutationAddRemove.nextElemXPath = getDomPath(mutation.nextSibling);
									// 			}
									// 		}
									// 		if (mutation.previousSibling) {
									// 			if (mutation.previousSibling) {
									// 				mutationAddRemove.prevElemXPath = getDomPath(mutation.previousSibling);
									// 			}
									// 		}
									// 	}

									// 	else if (mutation.removedNodes.length > 0) {
									// 		mutationAddRemove.name = 'removeElemMutation';
									// 		if (mutation.nextSibling) {
									// 			if (mutation.nextSibling.nextElementSibling) {
									// 				mutationAddRemove.nextElemXPath = getDomPath(mutation.nextSibling.nextElementSibling);
									// 			}
									// 			else {
									// 				mutationAddRemove.nextElemXPath = null;
									// 			}
									// 		}
									// 		else {
									// 			mutationAddRemove.nextElemXPath = null;
									// 		}

									// 		if (mutation.previousSibling) {
									// 			if (mutation.previousSibling.previousElementSibling) {
									// 				mutationAddRemove.prevElemXPath = getDomPath(mutation.previousSibling);
									// 			}
									// 			else {
									// 				mutationAddRemove.nextElemXPath = getDomPath(mutation.previousSibling);
									// 			}
									// 		}
									// 		else {
									// 			mutationAddRemove.prevElemXPath = null;
									// 		}
									// 	}

									// 	chat.sendBroadcastEvent(mutationAddRemove);
									// }
									// else {
										if (mutation.target.outerHTML) {
											let copyMutation = mutation.target.cloneNode(true);
											let mutationId = mutation.target.getAttribute('id');
											// не отправляем мутации связанные с блоком выделения менеджера
											if (mutationId != 'managerSelected') {
												// если мутировало изображения и у него в src base64, то ставим вместо него заглушку
												if (copyMutation.tagName.toLowerCase() === 'img') {
													let base64Width = mutation.target.clientWidth;
													let base64Height = mutation.target.clientHeight;
													let imgSrc = copyMutation.getAttribute('src');
													if (imgSrc.indexOf('base64') >= 0) {
														copyMutation.setAttribute('src', 'http://www.wxrl.com/uploads/3/4/7/1/34713038/nyc_orig.jpg');
														copyMutation.style.width = base64Width + 'px';
														copyMutation.style.height = base64Height + 'px';
													}

													elemMutation = {
														name: 'mutation',
														target: copyMutation.outerHTML,
														xPath: getDomPath(mutation.target)
													};

													// вырезаем лишние пробелы из мутации
													elemMutation.target = elemMutation.target.replace(/\s{2,}/g, ' ');
													// формируем массив с мутациями
													mutationsArray.mutations.push(elemMutation);
												}
												else if (copyMutation.tagName.toLowerCase() === 'ymaps') {
													// console.log(copyMutation);
												}
												else {
													// ищем внутри мутации все изображения и если у них в src base64 то выпиливаем его и ставим заглушку
													let imgInMutation = mutation.target.querySelectorAll('img');
													let imgSizes = [];
													// перебираем все изображения и создаем массих с их размерами
													// для того что бы подставить эти размеры для заглушки изображений с base64 в мутации
													imgInMutation.forEach(function (item) {
														// let imgSrc = item.getAttribute('src');
														let itemSize = {
															width: item.clientWidth,
															height: item.clientHeight
														}
														imgSizes.push(itemSize);
													});

													// перебираем все изображения в копии мутировавшего элемента и заменяем все изображения с base64 на заглушку и устанавливаем ей корректные размеры
													let imgCopyMutation = copyMutation.querySelectorAll('img');
													imgCopyMutation.forEach(function (item, i) {
														let imgSrc = item.getAttribute('src');
														if (imgSrc.indexOf('base64') >= 0) {
															item.setAttribute('src', 'http://www.wxrl.com/uploads/3/4/7/1/34713038/nyc_orig.jpg');
															item.style.width = imgSizes[i].width + 'px';
															item.style.height = imgSizes[i].height + 'px';
														}
													});

													elemMutation = {
														name: 'mutation',
														target: copyMutation.outerHTML,
														xPath: getDomPath(mutation.target)
													};

													// вырезаем лишние пробелы из мутации
													elemMutation.target = elemMutation.target.replace(/\s{2,}/g, ' ');
													// формируем массив с мутациями
													mutationsArray.mutations.push(elemMutation);
												}
											}
										}
									// }
								}
							}
						});

						// Добавляем обработчик скролла ко всем div на странице после мутации (для динамически добавленных элементов)
						document.querySelectorAll('div').forEach(function (item) {
							item.addEventListener('scroll', function (event) {
								if (localStorage.getItem('screenBroadcast')) {
									let elemScroll = {
										name: 'scroll',
										target: getDomPath(event.target),
										scrollTop: event.target.scrollTop,
										scrollLeft: event.target.scrollLeft
									};

									chat.sendBroadcastEvent(elemScroll);
								}
							});
						});
					}
				});


				// конфигурация observer:
				let observConfig = {
					attributes: true,
					childList: true,
					characterData: true,
					subtree: true
				};

				// передаём в качестве аргументов целевой элемент и его конфигурацию
				observer.observe(observTarget, observConfig);

				// обработка исключений для трансляций 
				document.querySelectorAll('*').forEach(function (item) {
					// находим все эллементы с не транслируемым классом
					if (item.classList.contains('ym-disable-keys')) {
						if (item.nodeName.toLowerCase() === 'input') {
							// IE Браузеры и Edge не корректно работают с evlutr  если в начале xPath нет html
							let relativePath;
							// Если edge браузер
							if (document.documentMode || /Edge/.test(navigator.userAgent)) {
								relativePath = getDomPath(item);
							}
							else {
								relativePath = getDomPath(item).split('/');
								relativePath = relativePath.slice(2);
								relativePath = '/' + relativePath.join('/');
							}

							let hiddenElem = document.evaluate(relativePath, correctHTML, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
							hiddenElem.setAttribute('value', 'Содержимое поля недоступно');
						}
						else {
							// IE Браузеры и Edge не корректно работают с evlutr  если в начале xPath нет html
							let relativePath;
							// Если edge браузер
							if (document.documentMode || /Edge/.test(navigator.userAgent)) {
								relativePath = getDomPath(item);
							}
							else {
								relativePath = getDomPath(item).split('/');
								relativePath = relativePath.slice(2);
								relativePath = '/' + relativePath.join('/');
							}

							let subElem = "<div style='width:" + item.offsetWidth + "px; height:" + item.offsetHeight + "px; background: url(https://223421.selcdn.ru/chatix-dev/assets/img/chatix_hidden_elem.png);'></div>";
							let hiddenElem = document.evaluate(relativePath, correctHTML, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;

							hiddenElem.innerHTML = subElem;
						}
					}
					// находим все поля с паролем что бы скрыть их от трансляции
					else if (item.getAttribute('type') === 'password') {
						// IE Браузеры и Edge не корректно работают с evlutr  если в начале xPath нет html
						let relativePath;
						// Если edge браузер
						if (document.documentMode || /Edge/.test(navigator.userAgent)) {
							relativePath = getDomPath(item);
						}
						else {
							relativePath = getDomPath(item).split('/');
							relativePath = relativePath.slice(2);
							relativePath = '/' + relativePath.join('/');
						}

						let hiddenElem = document.evaluate(relativePath, correctHTML, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
						hiddenElem.setAttribute('value', 'pass_was_hidden');
					}

					// находим все элементы со скроллом отличным от 0 в момент начала трансляции
					if (item.scrollTop || item.scrollLeft) {
						let scrollElem = {
							target: getDomPath(item),
							scrollTop: item.scrollTop,
							scrollLeft: item.scrollLeft
						}
						scrolledElems.push(scrollElem);
					}
				});

				// удаляем все скрипты из HTML Отправляемой страницы
				correctHTML.querySelectorAll('script').forEach(function (item) {
					item.removeAttribute('src');
					item.innerHTML = '';
				});

			
				// broadcastData.innerHTML = document.getElementsByTagName('html')[0].innerHTML;
				broadcastData.screenWidth = document.body.clientWidth + widthScroll();
				broadcastData.screenHeight = window.innerHeight;
				broadcastData.domain = location.origin + '/';
				broadcastData.mousePosition = {};
				broadcastData.scrolledElems = scrolledElems;
				broadcastData.visitorId = chat.visitor.uuid;
				broadcastData.htmlId = document.getElementsByTagName('html')[0].getAttribute('id');
				broadcastData.htmlClass = document.getElementsByTagName('html')[0].getAttribute('class');

				// если трансляция запущена, то при каждом обновлении или смене страницы отправляем данные
				if (localStorage.getItem('screenBroadcast')) {
					if (chat.connection) {
						if (chat.connection.getConnectionState() === 2) {
							chat.sendBroadcastData(correctHTML.innerHTML, broadcastData);
						}
					}
				}
				// КОНЕЦ ТРАНСЛЯЦИИ ЭКРАНА ВИЗИТОРА
			}
		}
	}
	managerEvents(data){
		clearTimeout(this.areaRemoveTimeout);
         if (data === 'removeSelectedArea') {
            let selectedBlock = document.querySelectorAll('#managerSelected')[0];
            if (selectedBlock) {
               selectedBlock.style.display = 'none';
            }
         }
         else if (data === 'endSelectedArea') {
            this.areaRemoveTimeout = setTimeout(function () {
               let selectedBlock = document.querySelectorAll('#managerSelected')[0];
               if (selectedBlock) {
                  selectedBlock.style.display = 'none';
               }
            }, 3500);
         }
         // рисование области выделяемой менеджером
         else {
            let selectedBlock = document.querySelectorAll('#managerSelected')[0];
            if (selectedBlock) {
               selectedBlock.style.display = 'block';
               selectedBlock.style.position = 'absolute';
               selectedBlock.style.boxShadow = '0px 0px 0px 100000px rgba(0, 0, 0, 0.6)';
               selectedBlock.style.zIndex = 1060;
               // условия для чтого что бы выделение работало не только по направления слева-направо, сверху-вниз, а в любую сторону
               selectedBlock.style.width = Math.abs(data.end.x - data.start.x) + 'px';
               selectedBlock.style.height = Math.abs(data.end.y - data.start.y) + 'px';
               if (data.start.y <= data.end.y) {
                  selectedBlock.style.top = data.start.y + -document.documentElement.getBoundingClientRect().top + 'px';
               }
               else {
                  selectedBlock.style.top = data.end.y + -document.documentElement.getBoundingClientRect().top + 'px';
               }

               if (data.start.x <= data.end.x) {
                  selectedBlock.style.left = data.start.x + -document.documentElement.getBoundingClientRect().left + 'px';
               }
               else {
                  selectedBlock.style.left = data.end.x + -document.documentElement.getBoundingClientRect().left + 'px';
               }
			}
		}
	}
}

// формирование xPath для елемента
function getDomPath(el) {
	var stack = [];
	while (el.parentNode != null) {
		var sibCount = 0;
		var sibIndex = 0;
		for (var i = 0; i < el.parentNode.childNodes.length; i++) {
			var sib = el.parentNode.childNodes[i];
			if (sib.nodeName == el.nodeName) {
				if (sib === el) {
					sibIndex = sibCount;
				}
				sibCount++;
			}
		}
		if (el.hasAttribute) {
			if (el.hasAttribute('id') && el.id != '') {
				stack.unshift(el.nodeName.toLowerCase() + "[@id='" + el.id + "']");
			} else if (sibCount > 1) {
				// потому что eq начинается с 0, а индекс xPath с 1
				sibIndex = sibIndex + 1;
				stack.unshift(el.nodeName.toLowerCase() + '[' + sibIndex + ']');
			} else {
				stack.unshift(el.nodeName.toLowerCase());
			}
		}

		el = el.parentNode;
	}

	let path = stack.slice(1);

	if (path.length > 0) {
		path = '/html/' + path.join('/')

		return path;
	}
}

// Получение ширины скрола браузера
function widthScroll() {
	let divElem = document.createElement('div');
	divElem.style.overflowY = 'scroll';
	divElem.style.width = '50px';
	divElem.style.height = '50px';
	divElem.style.visibility = 'hidden';
	document.body.appendChild(divElem);
	let scrollWidth = divElem.offsetWidth - divElem.clientWidth;
	document.body.removeChild(divElem);
	return scrollWidth;
}

export default ScreenBroadcast;
